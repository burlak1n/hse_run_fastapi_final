# TODO - Backend HSE RUN

## Общие улучшения (Монолит)

- [ ] Внедрить Сервисный слой между роутерами и DAO для улучшения разделения ответственности.
- [ ] Рассмотреть замену `asyncio.sleep` в `app/tasks` на более надежную систему фоновых задач (Celery, ARQ, FastAPI BackgroundTasks).
- [ ] Унифицировать обработку ошибок API (единый формат ответа).
- [ ] Увеличить покрытие кода тестами (unit, integration).
- [ ] **Удалить ручную проверку SQL-инъекций** в `BaseDAO._validate_input` (полагаться на параметризацию SQLAlchemy).
- [ ] Рассмотреть переход на PostgreSQL в production.
- [ ] Внедрить кеширование (Redis) для часто запрашиваемых данных.
- [ ] Добавить Rate Limiting для API эндпоинтов (`slowapi`).
- [ ] Настроить CI/CD пайплайны.
- [ ] Обернуть приложение в Docker для консистентности и деплоя.
- [ ] Настроить комплексный Мониторинг и Алертинг (Prometheus, Grafana, Sentry/Glitchtip).

## Перенос Auth модуля в Rust микросервис

Цель: Выделить всю логику аутентификации, авторизации, управления пользователями, командами и сессиями в отдельный, высокопроизводительный микросервис на Rust.

### 1. Планирование и Дизайн

- [ ] Определить точные границы нового `AuthService`:
    - [ ] Функционал: Управление пользователями (CRUD), регистрация/логин, управление сессиями (создание, проверка, инвалидация), управление командами (CRUD, join/leave), управление ролями.
    - [ ] Какие данные/связи остаются в основном монолите? (Например, связь User <-> Quest Progress).
    - [ ] Как будет обрабатываться логика, связанная с QR (если она относится к auth)? Переносится или остается?
    - [ ] Как будет обрабатываться логика программы лояльности (связь с пользователем)?
- [ ] Спроектировать API контракты для `AuthService` (RESTful, определить эндпоинты, request/response схемы). Использовать OpenAPI/Swagger для описания.
- [ ] Выбрать основной веб-фреймворк Rust (см. Рекомендуемый стек).
- [ ] Выбрать ORM / DB client (см. Рекомендуемый стек).
- [ ] Выбрать библиотеки для:
    - Хеширования паролей (Argon2, bcrypt).
    - Управления сессиями/токенами (JWT или DB-backed).
- [ ] Определить стратегию работы с БД:
    - [ ] Общая БД с монолитом (проще начать, но сильное связывание).
    - [ ] Отдельная БД для `AuthService` (чище, но требует миграции/синхронизации данных).
- [ ] Спланировать миграцию данных (если отдельная БД или смена схемы/алгоритмов хеширования).
- [ ] Определить стратегию коммуникации между сервисами (REST API, gRPC).

### 2. Настройка Rust проекта (`auth_service`)

- [ ] Инициализировать проект (`cargo new auth_service`).
- [ ] Добавить зависимости в `Cargo.toml` (веб-фреймворк, DB client, хеширование, JWT/сессии, логирование, конфигурация, обработка ошибок).
- [ ] Настроить конфигурацию (переменные окружения, `config` crate).
- [ ] Настроить логирование (`tracing`).
- [ ] Настроить обработку ошибок (`anyhow`, `thiserror`).

### 3. Реализация основной логики (Rust)

- [ ] Определить структуры данных / модели БД (в соответствии с выбранной стратегией БД).
- [ ] Реализовать User CRUD.
- [ ] Реализовать логику регистрации (хеширование пароля).
- [ ] Реализовать логику логина (проверка пароля).
- [ ] Реализовать управление сессиями (генерация токенов/идентификаторов, сохранение в БД/Redis, валидация).
- [ ] Реализовать управление командами.
- [ ] Реализовать управление ролями и правами доступа.
- [ ] Реализовать логику QR-кодов (если переносится).
- [ ] Реализовать взаимодействие с программой лояльности (если требуется).

### 4. Реализация API (Rust)

- [ ] Определить API роуты/хендлеры в выбранном фреймворке.
- [ ] Настроить сериализацию/десериализацию запросов/ответов (`serde`).
- [ ] Реализовать логику API хендлеров, вызывающую основную бизнес-логику.
- [ ] Добавить middleware для аутентификации/авторизации (проверка сессий/токенов).

### 5. Интеграция с Python Монолитом

- [ ] Заменить использование `app.auth` DAO и зависимостей в Python коде на HTTP-вызовы к `AuthService` (использовать `httpx`).
- [ ] Обновить FastAPI зависимость `get_current_user` для валидации сессии/токена через вызов `AuthService`.
- [ ] Обработать возможные сетевые ошибки и тайм-ауты при вызовах `AuthService`.
- [ ] Настроить передачу идентификатора пользователя/сессии между сервисами.

### 6. Тестирование

- [ ] Написать Unit-тесты для Rust кода (бизнес-логика, утилиты).
- [ ] Написать Integration-тесты для API `AuthService` (с тестовой БД/заглушками).
- [ ] Написать Integration-тесты на стороне Python для проверки корректности взаимодействия с `AuthService`.
- [ ] Провести нагрузочное тестирование `AuthService`.

### 7. Развертывание

- [ ] Создать Dockerfile для `AuthService`.
- [ ] Обновить конфигурацию развертывания (Docker Compose, Kubernetes) для включения нового сервиса.
- [ ] Настроить сетевое взаимодействие (роутинг, возможно API Gateway).
- [ ] Настроить мониторинг и алертинг для `AuthService`.

### 8. Очистка

- [ ] После стабилизации и полного перехода трафика на `AuthService`, удалить директорию `app/auth` из Python проекта.
- [ ] Удалить связанные зависимости из `requirements.txt`.
- [ ] Удалить неиспользуемый код.

---

## Рекомендуемый стек Rust для Highload Auth Service

- **Веб-фреймворк:**
    - `axum`: Современный, построен поверх Tokio, хорошо интегрируется с `tower` (middleware), отличная экосистема. **(Рекомендуется)**
    - `actix-web`: Зрелый, очень быстрый, акторная модель (может быть сложнее для понимания).
- **Асинхронный Runtime:**
    - `tokio`: Стандарт де-факто, используется большинством фреймворков и библиотек.
- **База данных:**
    - `PostgreSQL`: Проверенное решение для highload, множество функций.
- **Клиент БД:**
    - `sqlx`: Асинхронный, безопасный (проверки запросов во время компиляции), поддерживает PostgreSQL. **(Рекомендуется)**
    - `diesel`: Синхронный ORM (можно использовать в `tokio::spawn_blocking`), более высокий уровень абстракции.
- **Хеширование паролей:**
    - `argon2` (crate): Современный, устойчивый к GPU-атакам, рекомендован OWASP. **(Рекомендуется)**
    - `bcrypt` (crate): Все еще надежный, но менее ресурсоемкий.
- **Управление сессиями / Токенами:**
    - **DB-backed sessions:** Хранение идентификатора сессии в Redis (для скорости) или PostgreSQL, валидация через запрос к хранилищу. Дает полный контроль над сессиями (например, легкий отзыв).
    - **JWT (JSON Web Tokens):** (`jsonwebtoken` crate) Бесстейтовый подход, если нет необходимости немедленно отзывать токены. Валидация происходит локально. Можно комбинировать с refresh-токенами, хранящимися в БД/Redis.
- **Кеширование:**
    - `Redis` (`redis-rs` crate): Обязательно для highload для кеширования сессий, данных пользователей, результатов проверок прав.
- **Логирование:**
    - `tracing`: Мощная и гибкая система для структурированного логирования и трассировки.
- **Конфигурация:**
    - `config` + `dotenvy`: Загрузка конфигурации из файлов и переменных окружения.
- **Обработка ошибок:**
    - `thiserror`: Для создания кастомных типов ошибок.
    - `anyhow`: Для удобной обработки ошибок в приложениях.
- **Валидация данных:**
    - `validator`: Для валидации структур на основе атрибутов.
- **Развертывание:**
    - `Docker`: Контейнеризация.
    - `Kubernetes`: Оркестрация и масштабирование.
    - `Nginx` / `Envoy`: Reverse proxy, Load Balancer.
- **Мониторинг:**
    - Интеграция с Prometheus (`prometheus` / `metrics` crates).
    - Экспорт трейсов (Jaeger, OpenTelemetry).

- [ ] Авторизация для организаторов
- [x] Подумать, как встроить админку по адресу cms и вынести из файла main.py
- [ ] Поменять id ролей в коде на явные запросы
- [ ] Skeleton loading
- [ ] Улучшить роут qr/verify
- [x] Написать подсказки
- [x] Сделать ввод не только картинок, но и файлов
  - [x] Для загадок
  - [x] Для подсказок
- [ ] Сделать отображение загадки и для подсказки 
- [x] Если купить подсказку, то программа считает, что ты уже решил загадку
- [ ] Проверить то же самое для инсайдеров
- [ ] 